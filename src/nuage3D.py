# from mpl_toolkits.mplot3d import Axes3Dimport matplotlib.pyplot as pltfrom matplotlib import cmimport pandas as pdimport numpy as npimport matplotlib.animation as animation; animation.writers.list()import osdef nuagePnts3D(param):        #Récupération des données    # id, iterations, k, poids, metric, accuracy, f_score, precision, temps    fileName = 'resultats/belle_ile_tout.csv'    data = pd.read_csv(fileName)    K = np.array(data['k'].tolist()) # nombre de voisins    P = np.array(data['poids'].tolist()) # poids    M = np.array(data['metric'].tolist()) # métrique    D = np.array(data[param].tolist()) # résultats du paramètre étudié            # Configurer le graphique    fig = plt.figure()    ax = fig.gca(projection='3d')    # Ajouter les 3 nuages de points    if param == 'temps':        pnts = ax.scatter3D(K, P, M, zdir='z',s=40,depthshade=True, c = D, cmap = cm.get_cmap('winter').reversed())    else:        pnts = ax.scatter3D(K, P, M, zdir='z',s=40,depthshade=True, c = D, cmap = cm.get_cmap('autumn').reversed())        # Affichage    fig.colorbar(pnts, ax=ax)    if param == 'temps':        plt.title(param+' en secondes en fonction des 3 paramètres du KNN')    else:        plt.title(param+' en fonction des 3 paramètres du KNN')    ax.set_xlabel('Nombre de voisins')    ax.set_ylabel('Poids')    ax.set_zlabel('metric')        # # On enregistre le graphique en PNG    # my_path = os.path.abspath('resultats')    # my_file = 'nuage3D_'+param    # fig.savefig(os.path.join(my_path, my_file))        # # et en TIF    # def rotate(angle):    #     ax.view_init(azim=angle)    # rot_animation = animation.FuncAnimation(fig, rotate, frames=np.arange(0, 362, 2), interval=100)    # rot_animation.save('resultats/nuage3D_'+param+'.gif', dpi=80, writer='pillow')if __name__ == "__main__":        params = ['accuracy', 'f_score', 'precision', 'temps']        for param in params:        nuagePnts3D(param)    